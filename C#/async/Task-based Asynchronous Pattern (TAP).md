 Для работы с TAP используется простнансвто имен `System.Threading.Tasks`.
Приемущества TAP
- Простая инициализация и завершение асинхронной операции.
- Удобный способ получения возвращаемого значения асинхронной операции.
- Получения исключения, возникшего в асинхронной операции.
- Просмотр состояния асинхронной операции
- Поддержка отмены выполнения (необязательно)
- Продолжение задач (Task Continuations)
- Планирование выполнения асинхронной операции.

### Task (Задача)
Task - конструкция, которая реализзует модель параллельной обработки, основанной на обещаниях (Promise). Задача "обещает", что рабта будет выполнена позже, позволяя взаимодействовать с помощью "обещания" с чистым API.

### Стратегия параллельных вычислений Futures and promises
Существует две единицы - Future и Promise.
Future - Это представление переменной, доступной только для чтения (ссылка, на ещё не вычисленное значение). **Объект для результата, который ещё не существует.**
**Promise** - функция, которая присваевает значение Future. (т.е Future это возвращаемое значение функции Promise)

### Cпособ создания задачи
- Создание экземпляра Task и вызова на нем метода Start()
```cs
Task task new Task(new Action(Download));
task.Start();

 Task<int> task1 = new Task<int>(GetIntResult); //для возвращения значения из асинхронной операции
```
- C помощью фабрики задач и метода `StartNew()` (устаревший)
```cs
TaskFactory taskFactory = new TaskFactory();
taskFactory.StartNew(new Action(Download));
```
- Вызов статического метода `Task.Run()` (Наиболее пердпочтительный)
```cs
Task.Run(new Action(Download));
```
- Вызов метода `RunSynchronously()` для выполнения в основном потоке
```cs
Task task = new Task(new Action(Download));
task.RunSynchronously();
```
!!! **Попытка повторного запуска задачи приведет к исключению** `System.InvalidOperationException: 'Start may not be called on a task that was already started.'
`
### Холодные и горячие задачи
Холодная - не запущена на выполнение. Создается с помощью конструктора класса Task.
Горячая - задача, которая помимо создания сразу же и запускаеться. `StartNew()`, `Run()`

### Натройка задач
настройки задаются с помощью перечиления `TaskCreationOptions`
//TODO: дописать

### Ожидание выполнения задачи
`Task.Wait()` - вызывающий поток ожидает завершения выполнения задачи.
`Task.WaitAll(Task[] tasks)` -  вызывающий поток ожидает завершения выполнения всех задач в массиве.
`Task.WaitAny(Task[] tasks)` -  вызывающий поток ожидает завершения выполнения хотябы одной задачи в массиве.


### Передача параметров 
Для передачи параметров можно использовать лямбда-выражения.
```cs
Box box;
box.a = a;
box.b = b;

Task<int> task = new Task<int>(() => Calc(box));
task.Start();
Console.WriteLine($"Сумма чисел: {task.Result}");
private static int Calc(Box box)
{
	return box.a + box.b;
}
```

### Продолжения - Continuations
Продолжение - это асинхронная задача, вызываемая другой задачей при своем завершении. Это некий вариант метода обратного вызоыва (Callback method).

Для продолжения используют метод `ContinueWith()`
```cs
Task task new Task(Download);
Task contimuation = task.ContinueWith(ShowData);
```
Метод `ContinueWith()` возвращает новый экземпляр класса Task, что позволяет выстраивать цепочки продолжений.
``