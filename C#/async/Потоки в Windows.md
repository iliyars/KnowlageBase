Начиная с Windows NT, ядро операционной системы запускает каждый экземпляр прилодения в отдельном **процессе (process)**. Прцесс - это набор ресурсов, используемый коннкретным экземпляром приложения. Каждому процессу выделяется конкретное адресное пространство, гарнтируя, что код и данные одного процесса не буду доступны другим процессам. 
Для одновременной работы с прцессами были придуманы **потоки.**
**Поток** - концепция, которая предназанчена для виртуализцаии процессора в windows.
Windows-прцессу выдиляется собственый поток исполнения(функционирующий аналогично процессору), а при попадании кода приложения в бесконечный цикл - замораживается только связанный с этм кодом процесс, а остальные процессы исполняются в собственных потоках.

### Ресурсоемкость потоков
Потоки для своего создания требуют пространства(памяти) и времени(снижая производительность).
Каждый поток состоит из нескольких частей:
 - **Ядро потка (thread kernel)**. Операционная система для каждого созданного потока выдиляет и инициализирует структур данных. Набор свойств этой структуры оописывает этот поток. Структура содержит **контекст потока** то есть блок памяти с набором регистров процессора.
 - **Блок окржения потока (Thread Environment Blok, TEB)**. Это место в памяти, выделенное и инициализированное в пользовательском режиме (адресное пространство, к которому имеет быстрый доступ код приложения) . Этот блок занимает одну страницу памяти (4 Кбайт для процессоров х86 и х64). Он содержит заголовок цепочки обработки исключений.
 - **Стек пользовательского режима (user-mode stack)**. Применяется для передаваемых в методы лакальных переменных и аргументов. Также он содержит адрес, показывающий, откуда начнет исполнение поток, после того как текущий метод возвратит управление. 
 - **Стек режима ядра (kernel-mode stack)**. Используется когда код приложения передает аргументы в функцию ОС, находящуюся в режиме ядра. ..//TODO: Дописать.
 - **Уведомления о создании и завершении потоков**. Политика Windows таковва, что если в процессе создается поток, то для всех загруженных в процесс DLL-библиотек вызывается метод `DllMain` и в него передается флаг `DLL_THREAD_ATTACH`, А при завершении потока этому методу передается уже флаг `DLL_THREAD_DETACH`. Получая уведомления об этих событиях, некоторые библиотеки выполняют специальные операции инициализации или очистки созданного/завершенного в процессе потока. (Библиотеки для C# и многих других управляемых языков не имееют метода `DllMain` поэтому не получают уведомлений. В неуправляемы библиотеках с помощью Win32-функции `DisableThreadLibraryCalls` можно отключить режим получения уведомлений.)

